#!/usr/bin/env ruby
#
# = NAME
#
# cdnaobservations
#
# = SYNOPSIS
#
# See below, in opt parser block.
#
# = USAGE
#
# See below, in opt parser block.
#
# = AUTHOR
#
# daniel.lundin@scilifelab.se

$VERBOSE = true

require 'optparse'

FORMATS = {
  'json' => { 
    'call' => :jsoncall, 
    'desc' => 'JSON' ,
    'mandopts' => [ ]
  },
}
DEFAULT_FORMAT = 'json'
NUM_LINES_REPORT = 10000	# Print a period for each 10000 line of sam input read

def formats(format = false)
  if format and FORMATS[format]
    "#{format}: #{FORMATS[format]['desc']}\n"
  elsif format and format != ''
    "Format #{format} not supported\n"
  else
    "Supported formats:\n\t" + FORMATS.keys.sort.map { |f| "#{f}#{ f == DEFAULT_FORMAT ? ' * default *' : ''}" }.join("\n\t") + "\n"
  end
end

@options = {
  format: DEFAULT_FORMAT,
  input_separator: "\t",
  trunclen: 40
}
@annotations = { }	# Will contain keys for each ORF name pointing to a list of annotations

class AnnotationGroup
  attr_accessor :annotations, :n_specific, :n_unspecific

  def initialize
    @annotations = []
    @n_specific = 0
    @n_unspecific = 0
    @sorted = false
  end

  def to_s
    "AnnotationGroup, annotations: [#{annotations.map { |a| a.to_s }.join(", ")}]"
  end

  def json(indent)
    s = <<JSON
    {
      "n_specific": #{n_specific},
      "n_unspecific": #{n_unspecific},
      "taxons": [
	#{taxons.map { |t| t.json(indent) }.join(",\n")}
      ],
      "functions": [
	#{functions.map { |t| t.json(indent) }.join(",\n")}
      ]
    }
JSON
    s
  end

  def ==(annot_group)
    return false if self.annotations.length != annot_group.annotations.length
    self.sort!
    annot_group.sort!
    self.annotations.each_with_index do |a,i|
      return false unless a == annot_group.annotations[i]
    end
    true
  end

  def sort!
    return if @sorted
    @annotations = annotations.sort
    @sorted = true
  end

  def functions
    annotations.find_all { |a| a.type == 'function' }
  end

  def taxons
    annotations.find_all { |a| a.type == 'taxon' }
  end
end

class Annotation
  attr_accessor :db, :id, :name, :type

  def initialize(params)
    @type = params[:type]
    @db = params[:db]
    @id = params[:id]
    @name = params[:name]
  end

  def to_s
    "Annotation: type: #{type}, db: #{db}, id: #{id}, name: #{name}"
  end

  def json(indent = "    ")
    "{ \"source_db\": \"#{db}\" #{ id ? ", \"source_identifier\": \"#{id}\"" : "" } #{ name ? ", \"name\": \"#{name}\"" : "" } }"
  end

  def ==(annot)
    return false if type != annot.type
    return false if db != annot.db
    return false if id != annot.id
    return false if name != annot.name
    true
  end

  def <=>(annot)
    if ( n = self.type <=> annot.type ) != 0
      return n
    end
    if ( n = self.db <=> annot.db ) != 0
      return n
    end
    if ( n = self.name <=> annot.name ) != 0
      return n
    end
    return self.id <=> annot.name
  end
end

def annotation_parser(data, line_parser)
  ( type, db, filename ) = data.split(':')
  warn "Parsing name2orf, type: #{type}, db: #{db}, filename: #{filename}, line parser: #{line_parser}" if @options[:verbose]
  begin
    File.open(filename).each_with_index do |line, i|
      line.chomp!
      line.sub(/\s*#.*/, '')
      next if line == ''
      self.method(line_parser).call(type, db, line.split(@options[:input_separator]).map { |s| s.strip })
    end
  rescue
    warn "Failed to parse #{filename} as name2orf: #{$!}, backtrace:\n\t#{$!.backtrace.join("\n\t")}"
    exit 2
  end
end

def name2orf_line_parser(type, db, fields)
  name = fields.shift
  fields.each do |f|
    @annotations[f] ||= AnnotationGroup.new
    @annotations[f].annotations << Annotation.new(type: type, db: db, name: name)
  end
end

def orf2id_line_parser(type, db, fields)
  @annotations[fields[0]] ||= AnnotationGroup.new
  @annotations[fields[0]].annotations << Annotation.new(type: type, db: db, id: fields[1])
end

def jsoncall()
  warn "Printing #{@observations.values.inject(0) { |n,o| n + o.n_specific } } observations with #{@observations.values.length} annotation patterns in JSON format" if @options[:verbose]
  print <<JSON
{
#{`cat "#{@options[:header]}"`}
  "cdna_observations": [
#{@observations.keys.map { |k| @observations[k].json("    ") }.join(",")}
  ]
}
JSON
end

opt_parser = OptionParser.new do |opts|
  opts.banner = <<BANNER
cdnaobservations: Parses individual cDNA ORFs annotations plus a SAM formatted mapping of reads to ORFs, and outputs a summary as a json file
  cdnaobservations [options] file.sam
BANNER

  opts.on "--format=format", "Output format, default #{DEFAULT_FORMAT}"  do |v| 
    @options[:format] = v 
  end

  opts.on "--formats[=v]", "Lists available output formats or, with a format as parameter, writes a description of a format"  do |v|
    puts formats v 
    exit 0
  end

  opts.on "--header[=FILENAME]", "File containing the required header information: project, sample sets, samples. Without argument a template is written to stdout and the program terminates" do |v|
    if v
      @options[:header] = v
    else
      print <<JSONHEADER
# This is a template for the header information required in a cDNA observations
# JSON file for import into an environmentmicrobedb database.
#
# The file will be included verbatim though stripped of comments (like this
# line) and empty lines.
#
# One file per sample should be generated, there are no provisions for anything
# else unfortunately.
#
  "project": {
    "name": "__PROJECT_NAME__",				# E.g. Atlantic transcriptomics 2010
    "sample_sets": [
      {
	"name": "__SAMPLE_SET_NAME__",			# E.g. station 1 transcriptomes
	"samples": [
	  { "code": "__SAMPLE_CODE__" }			# E.g. Ca for added Carbon, replicate a
	]
      }
    ]
  },
  "annotation_source": {
    "dbname": "__DBNAME__",				# E.g NCBI NR
    "dbversion": "__DBVERSION__",			# Perhaps download date unless there is an official version number
    "algorithm": "__SHORT_DESCRIPTION_OF_ALGORITHM__"	# Something like 'Velvet assembly, FragGeneScan ORF calling, blastp, Megan LCA' perhaps
  }
JSONHEADER
      exit 0
    end
  end

  opts.on "-h", "--help", "This info"  do 
    puts opts
    exit 0
  end

  opts.on "--name2orf=TYPE:DB:FILE", "Annotation file of TYPE (taxon|function) coming from DB class-name<tab>orf-name format" do |v|
    annotation_parser(v, :name2orf_line_parser)
  end

  opts.on "--orf2id=TYPE:DB:FILE", "Annotation file of TYPE (taxon|function) coming from DB in orf-name<tab>id format" do |v|
    annotation_parser(v, :orf2id_line_parser)
  end

  opts.on "-v", "--verbose", "Be verbose"  do |v| 
    @options[:verbose] = v 
  end
end
begin
  opt_parser.parse!
  mandatory = FORMATS[@options[:format]]['mandopts'] + [ :header ]	# Fill in with mandatory option names (i.e. starting with :)
  missing = mandatory.select { |param| @options[param].nil? }
  unless missing.empty?
    warn "Missing options: #{missing.map { |m| "--#{m}" }.join(", ")}"
    warn opt_parser
    exit 1
  end
rescue OptionParser::InvalidOption, OptionParser::MissingArgument
  warn "#{$!}"
  warn opt_parser
  exit 1
end

warn "*** You have NO annotations, press Ctrl-C if this is in error, and correct your command line (try --verbose) ***" if @annotations == {}

warn "Parsed annotations for #{@annotations.keys.length} ORFs" if @options[:verbose]


unless FORMATS.keys.find { |f| f == @options[:format] }
  warn "Format #{@options[:format]} unsupported"
  warn formats
  exit 1
end

# Reduce AnnotationGroup objects to unique
@observations = {}
@annotations.keys.each do |annotkey|
  if identical_group = @observations.keys.find { |ag| ag == @annotations[annotkey] }
    @annotations[annotkey] = identical_group
  else
    @observations[@annotations[annotkey]] = @annotations[annotkey]
  end
end

def _find_longest_annotation_match(readname)
  unless @annotations[readname]
    i = -2
    while (r = readname[0..i]).length >= @options[:trunclen] and not @annotations[readname]
      if @annotations[r]
	#warn "#{__LINE__}: Found\n\t#{r} for\n\t#{readname}"
	@annotations[readname] = @annotations[r]
	break
      end
      i -= 1
    end
  end
  @annotations[readname]
end

# Loop over infiles
begin
  file = nil
  ARGV.each do |file|
    if file == '-'
      warn "Parsing STDIN" if @options[:verbose]
      io = STDIN
    else
      warn "Parsing #{file}" if @options[:verbose]
      if file =~ /.gz$/
	io = IO.popen("gunzip -c #{file}", "r")
      elsif file =~ /.bz2$/
	io = IO.popen("bunzip2 -c #{file}", "r")
      else
	io = File.new(file)
      end
    end
    io.each_with_index do |line,i|
      STDERR.print "." if i % NUM_LINES_REPORT == 0 and @options[:verbose]
      next if line[0] == '@'
      line.chomp!
      fields = line.split("\t")
      next if fields[2] == '*'
      if a = _find_longest_annotation_match(fields[2])
	a.n_specific += 1
      else
	warn "Found no annotation for #{fields[2]}"
      end
    end
    STDERR.puts if @options[:verbose]
  end
rescue
  warn "Failed to process file '#{file}': #{$!}, backtrace:\n\t#{$!.backtrace.join("\n\t")}"
end

# Print out the results
self.method(FORMATS[@options[:format]]['call']).call()
